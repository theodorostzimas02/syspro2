Θεόδωρος Τζίμας - 1115202000190 - sdi2000190
Ο κώδικας γίνεται compile με την εντολή make all, τα αρχεία διαγράφονται με την εντολή make clean και γίνεται seperate compilation.
Αρχικά, στον φάκελο include έχουμε το types.h το οποίο περιέχει κάποια define που χρησιμοποιούνται και στα δυο προγράμματα καθώς και τα structs για τον CommanderBuffer και το job.  Στο job περιέχονται τα job που ουσιαστικά είναι η εντολή προς εκτέλεση, το jobID που είναι το αναγνωριστικό του job και το socket από το οποίο ήρθε το job. Στο CommanderBuffer βρίσκεται ο actual buffer των εργασιών jobBuffer, το bufferSize που είναι το μέγεθός του, το currentJobs που είναι οι διεργασίες που τρέχουν μια δεδομένη χρονική στιγμή, το allJobs όλες οι εργασίες που έχουν εκτελεστεί (χρησιμοποιείται κυρίως για το assignment του jobID κατά την εκχώρηση μιας δουλειάς στο buffer), το mutex bufferMutex για κλείδωμα-ξεκλείδωμα του buffer από κομμάτια του κώδικα καθώς και το bufferCond που χρησιμοποιείται για busy waiting μέσω αποστολής και λήψης σημάτων. 
Στο jobCommander έχουμε τις μεταβλητές για τα αντίστοιχα arguments που παίρνουμε. Το mode ορίζει τον τύπο της εντολής που θα στείλουμε στον server. Μετά έχουμε N για concurrency, job για την δουλειά που διαβάσαμε εφόσον υπάρχει και jobID αντίστοιχα. Υπάρχουν σε όλες τις περιπτώσεις αντίστοιχοι έλεγχοι και μηνύματα σφαλμάτων. Εάν δώσουμε το issueJob τότε θα διαβάσει κάθε argument (π.χ. test case 3) και θα κάνει realloc κάθε φορά εάν με κάθε νέο argument χρειάζεται περισσότερο μέγεθος από το BUFSIZE που έχουμε ορίσει στο types.h . Στο τέλος προσθέτουμε τον χαρακτήρα “@” που όπως θα δείτε και παρακάτω χρησιμοποιείται από reads και writes όταν δεν υπάρχει καθορισμένο μέγεθος ώστε να μπορούμε να καταλάβουμε που τελειώνει κάθε μήνυμα. Με setConcurrency αλλάζουμε mode και το N, με stop mode και κρατάμε το jobID, με poll και exit αλλάζουμε modes. Στην συνέχεια με την gethostbyname παίρνουμε την IP πίσω από κάποιο όνομα προκειμένου να εγκαθιδρύσουμε σύνδεση σε ειδικό struct. Έπειτα με την forloop φτιάχνουμε και μια συμβολοσειρά με την IP για να την εκτυπώσουμε. Στην συνέχεια έχει σειρά το socket. Δημιουργούμε με την socket ένα καινούριο socket ενώ με τις inet_addr και htons μεταφράζουμε κατάλληλα το port που έχουμε δώσει και το resolved name του host. Με την connect εγκαθιδρύουμε σύνδεση μέσω όλων των παραπάνω. Η switch στην συνέχεια χειρίζεται κάθε mode κατάλληλα και στέλνει το αντίστοιχο μήνυμα. Στο mode 1 θα καλεστεί η συνάρτηση sendJob. Στην ουσία αυτή η συνάρτηση υπάρχει για να σταλθεί ένας ένας ο χαρακτήρας ώστε σε περίπτωση που είναι μεγάλο το κείμενο να μπορεί να διαβαστεί κατάλληλα πάλι χαρακτήρας χαρακτήρας. Στο τέλος εννοείται πως στέλνουμε και το terminating character “@”.  Αντίστοιχα, για να διαβάσουμε τα μηνύματα πίσω από τον server, για το mode 1 θα διαβάζουμε ένα ένα τους χαρακτήρες. Στην αρχή γίνεται malloc ο commitBuf με μέγεθος ενός χαρακτήρα. Όσο διαβάζουμε από τον server, τα total_chunks αυξάνονται και γίνεται και reallocate ο buffer μας κατά έναν χαρακτήρα κάθε φορά μέσα στην while. Αν βρεθεί terminating character, τον αντικαθιστούμε με το “\0” για να δηλώσουμε ότι τελειώνει το κείμενο. ΑΚΡΙΒΏΣ το ίδιο γίνεται από κάτω για τον buf ο οποίο όμως δεν περιμένει μήνυμα submit αλλά το response ανάλογα με την δουλειά που δόθηκε. Σε οποιοδήποτε άλλο mode τότε το BUFSIZE μας καλύπτει και απλά διαβάζουμε ολόκληρο το μήνυμα κατευθείαν και το εμφανίζουμε. 

Στο jobExecutorServer αντίστοιχα αρχικοποιούμε concurrency (αρχικό 1), threadPoolSize και active workers. Επίσης έχουμε έναν δείκτη στο CommanderBuffer struct σαν global μεταβλητή γιατί χρησιμοποιείται από πολλά σημεία του κώδικα στην συνέχεια και είναι εύκολα προσβάσιμος με αυτόν τον τρόπο. Στην αρχή κάνουμε resolve τα arguments από το command line. Δημιουργούμε τον buffer, αρχικοποιούμε τα στοιχεία του και στην συνέχεια περιμένουμε sockets. Στην συνέχεια δημιουργούμε τα worker threads βάση του threadPoolSize που έχει δοθεί. Θα τα αναλύσουμε στην συνέχεια καθώς καλούνται από τα controller threads. Να τονίσουμε ότι με την detach τα περιμένουμε ώστε να γυρίσουν αλλά να μπορούν να χρησιμοποιούν ξανά καθώς είναι τα threads που επαναχρησιμοποιούνται ώστε να «κάνουν την δουλειά» του server. Στην while κάνουμε accept κάθε ενδεχόμενη σύνδεση και δημιουργούμε για κάθε μια έναν controller thread στο οποίο μάλιστα περνάμε και το socket από το οποίο συνδέθηκε ο commander προκειμένου να είναι προσβάσιμο και να στέλνουμε πίσω μηνύματα. Με την phtread_join περιμένουμε τα threads να τελειώσουν και τα κλείνουμε. 
Στο controllerThread υπάρχει ίδια λογική με τον jobCommander. Διαβάζουμε ένα-ένα τους χαρακτήρες και αν υπάρχει ο «@» σταματάμε. Στην συνέχεια συγκρίνουμε με strncmp με το κατάλληλο μέγεθος εάν υπάρχει κάποια από τις εντολές που περιμένουμε και τις χειριζόμαστε αντίστοιχα. Για την issueJob καλούμε την συνάρτηση addJob. Η addJob κάνει allocate μια καινούρια job, περνάει αντίστοιχα το job, κάνει malloc το jobID, περνάει το socket και εν τέλη δίνει ένα jobID. Ωστόσο, μετά με το κατάλληλο κλείδωμα τσεκάρουμε εάν έχουν φτάσει τα currentJobs το μέγεθος του buffer. Εάν αυτό έχει γίνει τότε στέλνουμε αντίστοιχο μήνυμα πίσω. Εάν δεν ισχύει, τότε προσθέτουμε το job στον buffer και αυξάνουμε τα allJobs και currentJobs. Τότε στέλνουμε πίσω μήνυμα SUBMIT στον commander. Το buffer αυτή την φορά δεν κάνει συνεχώς realloc καθώς βασιζόμαστε στα lengths των jobID και job. Στην συνέχεια στέλνουμε σήμα σε όποιες διαδικασίες περιμένουν με το cond_signal και ξεκλειδώνουμε. Το setConcurrency τσεκάρει αν το concurrency είναι μεγαλύτερο του αριθμού των worker threads και στέλνει αντίστοιχο μήνυμα. Μετά καλεί την setConcurrencyLevel που απλά αλλάζει το concurrency. Για το stop καλείται η stopJob. Η stopJob καλεί την searchJob που τρέχει τον πίνακα μέχρι να βρει (εάν βρει) το job με το αντίστοιχο jobID. Εάν δεν βρεθεί τότε θα σταλθεί πίσω στον commander αντίστοιχο μήνυμα. Εάν βρεθεί, καλούμε την removeJob προκειμένου να την αφήσουμε. Η removeJob κάνει free ό,τι έχει γίνει malloc/strdup στα jobs και στην συνέχεια αφαιρεί την εργασία και pushάρει προς τα μπροστά τα υπόλοιπα στοιχεία ενώ το τελευταία το κάνει NULL. Έχουν αρχικοποιηθεί όλα με NULL οπότε μόνο το τελευταίο έχουμε λόγο να κάνουμε NULL, εάν είναι full ο buffer και όταν αφαιρεθεί ένα job πρέπει να ανοίξουμε χώρο για καινούριο στο τέλος. Η poll καλεί την pollState η οποία δημιουργεί ένα response προκειμένου να χωράει ντουμπλέτες (αντί για τριπλέτες της προηγούμενης εργασίας) με τις δουλειές που βρίσκονται στον ενταμιευτή την δεδομένη στιγμή και να τις γυρίσει στον commander. Εάν δεν υπάρχουν δουλειές, γυρνάει το αντίστοιχο μήνυμα. Στην exit περιμένουμε να φτάσουν τα currentJobs στο 0 ώστε να μπορούμε να τερματίσουμε τον server και να στείλουμε στις δουλειές στον buffer το αντίστοιχο μήνυμα. 
Στο workerThread γίνεται τελικά η εκτέλεση των jobs. Γίνεται busy waiting μέχρι να δεχθεί σήμα ώστε να ξανατσεκάρει τα currentJobs και τα activeWorkers εάν π.χ. αλλάξει το concurrency. Όταν δεχθεί εργασία/ αλλάξουν τα activeWorkers ή concurrency τότε θα βρει μια δουλειά από τον ενταμιευτή. Θα περάσει τα στοιχεία της και θα την κάνει remove με την removeJob. Έπειτα θα γίνει fork για να δημιουργηθεί ένα child process το οποίο θα αντικατασταθεί από την execvp στην συνέχεια για να εκτελέσει το job. Για να γίνει αυτό, το child process δημιουργεί ένα αρχείο με το pid του στο οποίο θα γραφτούν με την dup2 όλα αυτά που θα εμφανίζονταν στο terminal από το stdout. Έπειτα χωρίζει την εντολή από τα υπόλοιπα arguments και καλεί την execvp κατάλληλα. Με την waitpid ο parent περιμένει να τελειώσει το child process . Εφόσον τελειώσει θα διαβάσει το αρχείο με το pid που δημιουργήθηκε προηγουμένως και θα δημιουργήσει ένα buffer με κατάλληλο size. Στην συνέχεια θα σταλθεί στον commander τα μηνύματα start και end ενώ ενδιάμεσα character by character όπως και πριν θα σταλθεί το αρχείο που δημιουργήθηκε. Στο τέλος στέλνεται και το termination character για να σταματήσει το διάβασμα. Έπειτα διαγράφεται το αρχείο, μειώνονται τα active workers προκείμενου κάποιο άλλο worker να πάρει δουλειά και στέλνεται σήμα ότι άλλαξε αυτό για τα busy waitings. 
Στο test folder υπάρχει το progDelay που χρησιμοποιείται κατά κόρον από τα test scripts (επίσης στον ίδιο φάκελο). 

